\documentclass[14pt]{article}

\usepackage[letterpaper,bindingoffset=0.2in,%
            left=1in,right=1in,top=1in,bottom=1in,%
            footskip=.25in]{geometry}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage[makeroom]{cancel}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{tabularx}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.11}
\usepackage{systeme}
\usepackage{calc}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{multicol}
\usepackage{listings}

\lstset{language=Python}

\usetikzlibrary{calc}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows,decorations.markings}

\graphicspath{ {./images/} }


% DOCUMENT STARTS HERE

\begin{document}

\title{Analysis H Project: \\ \textbf{3D Graphics Generation with Matrices}}
\author{Mihir Rao}
\maketitle

\begin{center}
	\vspace{3em}
	\includegraphics[scale=0.8]{titleImg}
	\vspace{3em}
\end{center}

\section*{Overview}

For our Analysis H project, Steve and I decided to dive into the realm of computer graphics and matrices' applications in this field. Specifically, we wrote code that generates 3D points, projects these 3D points onto a 2D surface(the computer screen), and transforms these points to display an animation(using matrices). We both were fascinated by the numerous applications of matrices and thought this will be a fun project to work on. After doing further research, it also turns out that Renderman, Pixar's animation software, is heavily based on matrices and linear algebra; so this was the perfect time for us to dip our toes in the fundamentals of this field. This document serves to explain how we came up with the math of this code, challenges we faced, and the ultimate solutions to those challenges. The next section is a brief introduction of how we approached the code and following that is the actual math behind it. Enjoy!

\newpage

\section*{The Math}

There are many aspects of the code that we had to come up with in order to display an animated 3D object on a 2D screen. Some of these aspects rely more on math than others and this document will go over those functions in \textcolor{blue}{\href{https://github.com/itsmehere/SpinningCube/blob/main/cubeProj.py}{this code}}.

\subsection*{Coordinate Setup}

\begin{figure}[!htb]
    \centering
    \subfloat[\centering]{{\includegraphics[width=5cm]{cartesianCoordinates} }}%
    \qquad
    \subfloat[\centering]{{\includegraphics[width=5cm]{computerCoordinates} }}%
    \caption{Coordinates}%
    \label{fig:example}%
\end{figure}

In the figures above, we see (a): our regular cartesian coordinate system where (0,0) is at the center of the screen and we have 4 quadrants. However, in figure (b), we see a generic computer coordinate system--where (only the 4th quadrant is included making the origin the top left of the screen. Though it may seem more complex to display animations at a point other than the origin, computer screen layouts actually make this problem easier(with a little bit more math of course) since we no longer have to deal with negative values. So why is this important? Well, if we wanted to display an object at the center of the screen, or in fact, any point other than the origin, we'd have to come up with some sort of way to cleverly use matrices and transformations. We'll start of with our generic 2 x 2 rotation matrix.

\vspace{1em}

\begin{figure}[h]
	\vspace*{1em}
	\begin{center}
		\begin{minipage}[b]{0.45\textwidth}
			\centering
			
			$$
			\begin{bmatrix}
			cos(\theta) & -sin(\theta) \\
			sin(\theta) & cos(\theta)
			\end{bmatrix}
			$$
		\end{minipage}
		\hfill
		\begin{minipage}[b]{0.45\textwidth}
			\centering
			$$
			\begin{bmatrix}
			1 & 0 \\
			0 & 1
			\end{bmatrix}			
			$$
		\end{minipage}
	\end{center}
	\vspace*{1em}
\end{figure}

\vspace{1em}

A couple things that are important to note before we proceed are that this matrix rotates points in 2 dimensions and on the $xy$ plane--meaning around the $z$ axis. Since we need to go into 3D, we need to change this matrix to work for 3D points and we can do that by using the concept of an identity matrix. Shown as the top right matrix, we can multiply the rotation matrix by this and still obtain the same rotation matrix. A 3x3 identity matrix is the just the same and we can use that concept to come up with a rotation matrix for 3D. These new matrices are shown below.

\begin{figure}[h]
	\vspace*{1em}
	\begin{center}
		\begin{minipage}[b]{0.45\textwidth}
			\centering
			
			$$
			\begin{bmatrix}
			cos(\theta) & -sin(\theta) & 0 \\
			sin(\theta) & cos(\theta) & 0 \\ 
			0 & 0 & 1
			\end{bmatrix}
			$$
		\end{minipage}
		\hfill
		\begin{minipage}[b]{0.45\textwidth}
			\centering
			$$
			\begin{bmatrix}
			1 & 0 & 0 \\
			0 & 1 & 0 \\
			0 & 0 & 1
			\end{bmatrix}			
			$$
		\end{minipage}
	\end{center}
	\vspace*{1em}
\end{figure}

Just like we can add on another row and column to the identity matrix, to get the matrix for the new dimension, we can do the same for the rotation matrix. To prove this works, we can take any point and verify its coordinates using both matrices.

\vspace*{1em}

\begin{equation}
	\begin{bmatrix}
	cos(\theta) & -sin(\theta) & 0 \\
	sin(\theta) & cos(\theta) & 0 \\ 
	0 & 0 & 1
	\end{bmatrix}
	\begin{bmatrix}
	1 \\
	0 \\ 
	0
	\end{bmatrix}	
	=
	\begin{bmatrix}
	cos(\theta) \\
	sin(\theta) \\ 
	0
	\end{bmatrix}
\end{equation}

\vspace*{1em}

\begin{equation}
	\begin{bmatrix}
	cos(\frac{\pi}{2}) & -sin(\frac{\pi}{2}) & 0 \\
	sin(\frac{\pi}{2}) & cos(\frac{\pi}{2}) & 0 \\ 
	0 & 0 & 1
	\end{bmatrix}
	\begin{bmatrix}
	1 \\
	0 \\ 
	0
	\end{bmatrix}	
	=
	\begin{bmatrix}
	cos(\frac{\pi}{2}) \\
	sin(\frac{\pi}{2}) \\ 
	0
	\end{bmatrix}
\end{equation}

\vspace*{1em}

\begin{equation}
	\begin{bmatrix}
	0 & -1 & 0 \\
	1 & 0 & 0 \\ 
	0 & 0 & 1
	\end{bmatrix}
	\begin{bmatrix}
	1 \\
	0 \\ 
	0
	\end{bmatrix}	
	=
	\begin{bmatrix}
	0 \\
	1 \\ 
	0
	\end{bmatrix}
\end{equation}

\vspace*{1em}

As we can see above, we get the correct answer of (0, 1, 0) after rotating the point (1, 0, 0) by $\frac{\pi}{2}$ radians counter clockwise. Similarly, we can do this to the rotation matrices of not only the $z$ axis but also the $y$ and $x$ axes. Once we do this, we get the 3 rotation matrices for the $x$, $y$, and $z$ axes.

\begin{figure}[h]
	\vspace*{1em}
	\begin{center}
		\begin{minipage}[b]{0.3\textwidth}
			\centering
			
			$$
			\begin{bmatrix}
			1 & 0 & 0 \\
			0 & cos(\theta) & -sin(\theta) \\ 
			0 & sin(\theta) & cos(\theta)
			\end{bmatrix}
			$$
		\end{minipage}
		\hfill
		\begin{minipage}[b]{0.3\textwidth}
			\centering
			$$
			\begin{bmatrix}
			cos(\theta) & 0 & sin(\theta) \\
			0 & 1 & 0 \\
			-sin(\theta) & 0 & cos(\theta)
			\end{bmatrix}			
			$$
		\end{minipage}
		\hfill
		\begin{minipage}[b]{0.3\textwidth}
			\centering
			$$
			\begin{bmatrix}
			cos(\theta) & -sin(\theta) & 0 \\
			sin(\theta) & cos(\theta) & 0 \\
			0 & 0 & 1
			\end{bmatrix}			
			$$
		\end{minipage}
	\end{center}
	\begin{center}
		\begin{minipage}[t]{0.3\textwidth}
			\caption*{Rotation Matrix $X$.}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.3\textwidth}
			\caption*{Rotation Matrix $Y$.}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.3\textwidth}
			\caption*{Rotation Matrix $Z$.}
		\end{minipage}
	\end{center}
\end{figure}

(NOTE: Derivations of these matrices have been left out to keep paper length minimal). Now that we have our 3 main matrices, we can go back to the problem of a computer's coordinate system. If we were to use just these matrices themselves, our points would be rotating about the origin and the center of the cube would not stay fixed. So how might we solve this problem? The solution, we found, is to use translations. With translations, we can move every single coordinate to its prospective location around the origin. Then, we can rotate it using the matrices above. Finally, we have to bring the cube back to where it was so we use another translation matrix to do the exact same thing as the first, but in the opposite direction. 

\subsection*{Generate Points Function}



\subsection*{Points Between Function}



\subsection*{Create Composite Matrix Function}

\end{document}

\iffalse
\begin{figure}[h]
	\begin{center}
		\begin{minipage}[b]{0.45\textwidth}
			\centering
			
			$$\theta$$
		\end{minipage}
		\hfill
		\begin{minipage}[b]{0.45\textwidth}
			\centering
			$$\theta$$
		\end{minipage}
	\end{center}
	\vspace*{-2\baselineskip}
	\begin{center}
		\begin{minipage}[t]{0.45\textwidth}
			\caption{Transportation matrix $B$.}
			\label{fig:adjacency_b}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.45\textwidth}
			\caption{Graph of matrix $B$.}
			\label{fig:directed}
		\end{minipage}
	\end{center}
	\vspace*{-2\baselineskip}
\end{figure}
\fi